[
    {
        "url": "https://youtu.be/42iQKuQodW4?si=84rxUEFnpCtJQlaB",
        "transcript": "The Linux file system. It's a cryptic labyrinth of directories defined by the file system hierarchy standard. Navigate through it with the change directory command CD forward slash drops you into the root. Then with the LS command, we can list out the contents of this directory. First we have the bin directory, which contains binaries or executables that are essential to the entire operating system. You can run these binaries from the command line at any time, things like gzip, curl and even the LS command that we just ran. But confusingly, there's also an S bin directory. It contains system binaries that should only be executed by the root user like mount or delete user. Many of these binaries may share common libraries which are stored in the lib directory. Now we also have a USR user directory with its own bin and S bin directories. The binaries or applications here are nonessential to the operating system itself and intended for the end user. You'll also notice a local directory under User. It contains any binaries that you compile manually to provide a safe place that won't conflict with any software installed by a system package manager. All these binaries get mapped together with the path environment variable, and that's why you can execute them from any directory in the terminal. If you ever want to know where a binary lives, run, which followed by the binary name to view its full path in the file system. Now at some point you may want to customize the behavior of the software on your system. The etc directory stands for etc for editable text configuration. Many of these files end in and they're typically just text based config files that you can modify in your editor. As an operating system, Linux can support multiple users. In the home directory you'll find a folder named after each user registered on the system. It contains the files, configuration and software for that user, and you need to be logged in as that user or as a root user to modify it. Notice how the file path is a squiggly. That's your normal starting location when you open up a terminal session. Now let's go back to the root. There are a few more directories here that we haven't talked about yet. Like boot. It contains the files needed to boot the system, like the Linux kernel itself. Then we have Dev, which stands for device files. Here you can interface with hardware or drivers as if they were regular files. You might create disk partitions here or interface with your floppy drive. The op directory contains optional or addon software and you'll rarely interact with it. VAR contains variable files that will change as the operating system is being used, things like logs and cache files. Temp is for temporary files that won't be persisted between reboots. And finally we have the weirdest one of all. The proc directory is an illusionary file system that doesn't actually exist on the disk but is created in memory on the fly by the Linux kernel to keep track of running processes. This has been the Linux file system in 100 seconds. If you want to see more short videos like this, hit the like button and let me know what you want to see next in the comments. Thanks for watching and I will see you in the next one."
    },
    {
        "url": "https://youtu.be/kxT8-C1vmd4?si=xbNTd7lJFyPJV9dH",
        "transcript": "Zig, a high performance system programming language often labeled as a next generation alternative to C. It was created by Andrew Kelly in 2016 and has quickly evolved into one of the most desired new languages in the world. Like C, it's minimal, extremely fast, and allows for low level memory control. But instead of managing memory directly in the language with functions like Malloc and Free, the Zig standard library ships Allocators to provide a consistent interface for memory management. Miss Zig is not a memory safe language like Rust or Go, but it doesn't have any hidden memory allocations, making the code far more explicit and portable, because allocators can be easily swapped out in the code to target different architectures like X 86, Arm WebAssembly and Bare Metal. In addition, Zig has no hidden control flow. If it looks like a function and quacks like a function, it's a function there's no operator overloading, and it doesn't even have exceptions. If a function can fail, it needs to return an explicit error value. The language also has a unique comp time keyword that makes it trivial to run code at compile time instead of runtime, no preprocessor or macros are necessary. And finally, Zig can integrate well into a C or C code base and supports cross compilation out of the box with LLVM, although divorce paperwork has been filed. To get started, install Zig, then create a new project with the Zig init exe command in the main file. First import the standard library. Then define a main function. Notice how the function returns a type of void with an exclamation point. That exclamation point means that the function might return an error. Declare a mutable variable with the VAR keyword followed by a type like U eight to represent a single byte, then assign and modify its value later. Or use const to define an immutable variable that cannot be changed. We can also bundle multiple variables together into a struct, then access them on that namespace with dot notation. Now, things start to get more interesting when memory management comes into play. When initializing an array of integers, we can allocate it to a slice of memory in the heap using the built in page Allocator from the standard library. What's so cool about this is that we could swap it out with other allocators to use different memory management strategies. Now, when we're done with this memory, we need to set it free. Otherwise we could have a memory leak. The defer keyword allows us to put that code right next to the allocation itself and will automatically deinitialize the list when it goes out of scope. Now, as we operate on the list, the try keyword provides explicit error handling. If this line fails, it will automatically catch and return the error. You can't just ignore it, and that will make your code more reliable. And speaking of reliability, Zig has a built in testing framework. Use the test keyword to evaluate code outside of the main program. Then use the Zig test command to run it. And finally build an executable with the Zig build command and choose a build mode to optimize for speed, size or safety. This is been the Zig programming language in 100 seconds. Hit the like button if you want to see more short videos like this. Thanks for watching and I will see you in the next one."
    },
    {
        "url": "https://www.youtube.com/watch?v=mVKAyw0xqxw",
        "transcript": "It Tails OS, a free based AF operating system designed to protect you against malware, censorship and surveillance. It was first released in 2009 and became famous when Edward Snowden used it to communicate with reporters, exposing the government's mass surveillance programs. Most personal computers are just cool prisons that track your every movement and harvest your biometric data so advertisers can eventually unburden you from your money. Tails OS is a debian Linux distro that boots from a USB stick to turn any computer into a temporarily secure machine. When you finally discover the true shape of the Earth, you might think you're clever because you used a private browser and deleted all the files from your computer, but traces were left behind on disk that can be recovered via forensic analysis. And now they're going to try to unalive you. Tails helps you avoid this fate. Thanks to amnesia, everything you do disappears automatically when the OS shuts down, because Tails never writes anything to the hard disk and only runs from the memory on your computer. When you get a knock at the door, there's no need to rip out your hard drive and flush it down the toilet. Instead, just turn the computer off and all the totally legit and mundane things you just did will be lost forever. However, it is possible to store some information on the USB, like browser BOOKMARKS or documents that you want to persist between sessions. And of course, they're encrypted automatically when you boot it up. You'll find your favorite Ganu utilities, but also privacy focused software like the Tor browser, which routes Internet traffic through the Tor network, consisting of multiple layers of encrypted relays where no individual relay knows both where you're coming from and where you're going to conceal your location, IP address and usage. In fact, any application that tries to access the Internet without the Tor network is automatically blocked on Tails. This makes it a great option for journalists working on sensitive topics, victims of domestic abuse, or anyone who enjoys truly free software. Where free means freedom. What will you do without freedom? To get started, grab a USB stick with at least 8GB of memory, then download the version that matches your current OS. Now verify the file to ensure that it wasn't corrupted during download. Then use a tool like etcher to safely flash it on the USB stick. Next, make sure you have the official startup instructions on a separate device. Then on Windows, hold down the Shift key while clicking on the restart button from the Start menu. Then use the option to reboot from a device. This will bring up a boot menu where you can select the USB stick, at which point you can select Tails from the bootloader. And now we're officially running Tails. Go through the initial setup and most importantly, make sure you have a good connection to the Tor network. Congratulations, you now have a private and anonymous computer. Everything you do now is stored in random access memory and not on disk. In addition, when Tails shuts down, it will overwrite most of the Ram to prevent a cold boot attack where someone extracts memory dump from the Ram, which is often done in digital forensics to catch the bad guys. This has been Tails OS in 100 seconds, but don't tell anybody I told you about it. Thanks for watching and I will see you in the next one."
    },
    {
        "url": "https://www.youtube.com/watch?v=bOCHTHkBoAs",
        "transcript": "People often say you don't need to know any math to program a computer, and that's truthy. However, any sufficiently advanced technology is indistinguishable from magic. But magic isn't real. Math explains it all. Developers often avoid learning math because it looks scary, but it actually makes complicated magic like computer graphics and neural networks easier to understand. And not just that, but it unlocks the secrets of the entire physical universe. There's a few abstract math concepts for program grammars that you just can't ignore, and understanding them will make you think more like a true engineer. I'm no math genius. In fact, I'm the opposite, which makes me uniquely qualified to teach ten essential math concepts using memes and other visual AIDS that almost anybody can understand. The first person who survives until the end and cracks the code will win this one of a kind. Balenciaga fireship hoodie. Let's jump right into topic number one boolean algebra, which is used almost every time you write code. A boolean is a binary variable that can have two possible values true or false. Now, there are three operators that you can use to work with them and or and not or, conjunction, disjunction, and negation. If you want to be fancy, imagine you're trying to get a girlfriend. We can use the boolean variables of rich and handsome to describe you. If you're both rich and handsome, you'll definitely get a girlfriend. But if you're not rich and not handsome, you'll have to pay for an OnlyFans girlfriend. If you're rich or handsome, you can still get a girlfriend, but your selection is more limited. We can represent this logic and code with things like if statements, but we can also do it visually with Venn diagrams like you've been doing since grade school. And you can also create truth tables, like this one here, which comes in handy in zombie apocalypse type situations. But that brings us to concept two numeral systems like base two. Throughout history, humans have come up with all kinds of clever ways to count things, but almost all of them use base ten, like the ten fingers on your hands, like in the number 423. The four is in the hundreds place, which represents four times 100. The two is in the tens place, or two times ten. Then the final number is multiplied by one. But computers work off of a base two numeral system. In base two, things work the exact same way. But because we only have two symbols to work with, each place is multiplied by two, like two 4816, 326-4128, and so on. Now that you understand that, you also understand how other bases work, like base 16, or hexadecimal, which uses the digits zero through nine along with A through F, and is commonly used to represent binary values in a more concise way, because each hexadecimal digit can translate into four bits. And you also have base 64, which introduces even more letters and symbols to encode binary values, allowing developers to represent binary data like an image as a string of text. While computers use base two under the hood, they still need to represent base ten numbers for humans. And the most common way to do that is with floating point numbers. Go ahead and execute 0.1 plus zero two in your favorite programming language. The result should be 03004. How could a computer make such a silly mistake? Well, in science, numbers can get very big when talking about space and very small when talking about things like atoms. We don't write these numbers out completely and instead use scientific notation where an exponent raises it to an approximate value, making the number appear far more concise. Computers use a similar approach with floating point numbers because they only have a limited amount of space either 32 bits for single precision or 64 for double precision, which is the default in languages like Python and JavaScript. It's called a floating point because there's no fixed number of digits before or after the decimal point, allowing developers to make a tradeoff between range and precision. Some numbers, like zero one, can't be represented perfectly as a binary floating point, which is the reason we get those tiny rounding errors. Now that you know how numbers work, we can start talking about logarithmic functions, which you might remember from algebra class. To understand them, think of an actual log. The log starts at 16ft, then we saw it in half, over and over again until we reach a length of two. Notice how when we try to draw a line through it, it's not perfectly straight, but rather it curves gradually. In computer science, this is how many algorithms work like binary search. What's interesting, though, is that if we know how many times we cut the log, we can raise two to the power of that value, in this case, four, to get the original length of the log. That's called exponentiation, and logarithm is the exact opposite. Imagine we don't know the exponent, we only know the original length, and want to figure out how many times we'd have to cut the log to get a length of two. We could calculate that with a base two log on the original length, returning a value of four. When it's base two, it's called a binary logarithm. However, in math it's more common to use base ten, which is called the common logarithm. That'll come in handy. But now let's shift gears to set theory. A set is just an unordered collection of unique values. The best example is a relational database, where each table is a set of unique rows. These tables can be joined together in a variety of different ways based on set theory. Like to select records that match on both tables, you do an inner join, which is called an intersection in set theory. Or to grab all matching records from both tables, you do a full outer join. Which is a union in set theory. When doing left and right joins, these concepts are combined, like by combining an intersection with the difference between the two sets. Now, one thing that's important to notice at this point is that we're talking about structures that have a finite number of elements, which falls under the umbrella of discrete math, as opposed to continuous math like geometry and calculus that deal with real numbers and approximations. And that brings us to our next discrete topic combinatorics. Simply put, this is all about counting things, especially when combining sets into combinations or permutations. Like if you have an app like Tinder, you might need to count all the possible combinations of matches as part of a more complex algorithm that figures out what to show the end user. Or maybe you're building a globally distributed database and need to figure out how many database partitions you'll need around the world. Ultimately, it's all about understanding how patterns can emerge. What you're looking at here is the formula for the Fibonacci sequence. A great exercise is to write a function that generates it. Congrats, bro, you just did combinatorics and unlock the secrets of the universe. Engineers at Google use the same kind of logic to render tiles on tools like Google Maps, and the gods use this pattern all over the place. In nature, combinatorics is closely related to graph theory. A graph has two basic parts nodes or vertices and edges that connect them together. Like a person might be a node and an edge might be a relationship that connects them together. Like you love your mom and your mom loves you back. This is an undirected graph because the relationship goes both ways. However, you might also love your OnlyFans girlfriend, but this would be a directed graph because that relationship only goes one way. Edges can also be weighted, meaning one relationship is more important than the other. If a node can traverse back to itself, it's called cyclic. Otherwise it's known as acyclic. As a programmer, you'll often need to build graphs from the ground up, but more importantly, know how to traverse them. Like when using Dijkstra's algorithm to find the most efficient way to navigate through traffic. But before you start writing graph traversal algorithms, you should know a little bit about complexity theory, which can tell us in theory how much time and memory an algorithm should use. We use big O notation to express complexity, and when talking about time, the input represents the number of steps it will take to complete a task. Like if we read a single element from an array, that would give us O of one or constant time, which is extremely fast and simple. If we need to loop over an array, that would give us O of n, where n is the length of the array. But if for each iteration in that loop, we loop over the same array again, that would give us o of n squared, which would be far less efficient. However, more sophisticated algorithms like binary search cut the search area in half after each iteration, providing us with logarithmic time. Understanding how to measure complexity is essential for technical interviews and is just a good thing to think about in general. But now let's move away from discrete math and talk about statistics, which is crucial if you want to do anything with artificial intelligence, because machine learning is kind of just a fancy way of doing statistics. Like when you type into Chat GPT, it generates a response based on the probability that it fits the prompt provided by the user. At the very least, you should understand mean, median and mode, and how standard deviation indicates how close values in a set are correlated to the mean. There's a ton to learn beyond that, but what I found especially useful is the difference between linear regression and logistic regression. In a linear regression, the goal is to predict a continuous value, like the amount of money you'll lose after buying a stock. The relationship between the input and output variable is linear, and the idea is to find a line that best fits the data set. However, logistic regression is used for an entirely different set of problems, like classification, maybe an app that predicts if an image is a hot dog or not a hot dog. In this case, the relationship is not linear, but rather a sigmoid function, which might predict the probability that a Boolean variable is true or false. And that brings us to our final and most difficult topic linear algebra, which comes into play in things like computer graphics and deep neural networks. To comprehend it, you'll need to understand three weird words. Scalar is a single numeric value. A vector is a list of numbers, like a onedimensional array. And finally, a matrix is like a grid or two dimensional array that contains rows and columns of numeric values. What's cool is that vectors can represent points and directions in a 3D space, while matrices can represent transformations that happen to these vectors. When you move a player around in a video game, the lighting and shadows in the graphics change magically. But it's not magic. It's linear algebra that's being distributed on your GPU. Imagine you have a 2D vector that's at zero two x three y. It represents a single point in an image. We can perform linear transformations here, like scaling, translation, rotation, shear and so on. Let's imagine we now want to scale the point to a value of four x six y. We can represent the scaling factors in a matrix, then represent the point as a column vector. And now we can use matrix multiplication to scale the point to its target location. Operations like this are also essential in things like cryptography, such as RSA encryption, and are also essential in deep neural net works, which use vectors to represent features, then use matrix multiplication to propagate values between nodes in the network. The underlying math is surprisingly simple, but requires a massive amount of computing power to handle the staggering amount of data required. As you can see now, math is actually not that complicated, and the more you study it, the more the computer will reveal its magic tricks. Thanks for watching and I will see you in the next one."
    },
    {
        "url": "https://www.youtube.com/watch?v=lkIFF4maKMU",
        "transcript": "JavaScript. It's a wonderful programming language to learn for beginners. It's also a horrible programming language to learn for beginners. On one hand, you can build almost anything with it and get a job anywhere if you master it. On the other hand, it's weird, ugly, and surrounded by a dystopian wasteland of frameworks and libraries. Don't want to sound like a dick or nothing, but says on your chart that you're fucked up. Welcome to JavaScript 101. Over the next few minutes, you'll learn 101 different things you need to know about JavaScript, like how to use it, where to use it, and why it is the way it is. By the end of this video, you'll be able to build a website, a mobile app, a desktop app, a server, an operating system, artificial intelligence, and all kinds of other stuff you shouldn't build with it. It was created in 1993 by Brendan Ike at Netscape. At the time, the web browser was cutting edge technology that connected everybody on the planet via the World Wide Web. Now that I've gotten on the Internet, I'd rather be on my computer than doing just about anything. At the time, websites were completely static with pure HTML. JavaScript was designed as an easy to use, high level language to help developers make these websites interactive. Today, it's arguably the most popular language in the world, and its standard implementation is called ECMAScript and is the default language in all web browsers. In fact, it's the only code that natively runs in a browser. Aside from WebAssembly. However, the browser is not the only runtime, and you can also run JavaScript code on a server, thanks to tools like Node, JS and Dino. As the name implies, JavaScript is a scripting language that means you can execute code on the fly by opening up the console in your browser DevTools to run some code that changes the appearance of a website at any time. It's interpreted line by line, as opposed to other languages like C that are compiled ahead of time. However, interpreted is not the most accurate term to use here. Under the hood of the browser, there's an engine called v eight. It makes JavaScript run extremely fast by taking your code and converting it to machine code with a process called just in time compilation. But none of this stuff really matters. Let's jump into some code. To use JavaScript on a web page, you'll first need an HTML document, inside of which we'll have a script tag. You can write code inside the tag directly or reference an external file with the source attribute. Now, to say hello world, use Console Log, which is JavaScript's built in tool for printing to the standard output. Now open the HTML file in a browser and you should see the value printed out in the DevTools. There are several different ways to define variables, the most common of which today is let start by giving it a name which will normally be in Camel case, then assign a value to it. It's a dynamically typed language, which means no data type annotations are necessary. In this case, I've assigned a number which is one of the seven primitive data types built into the language. However, we don't need to assign the variable a value right now because it can be reassigned later without an assignment. It automatically uses the primitive value of undefined as its default value. However, we can explicitly represent an empty value using null and later on we could reassign that same variable to a string. It's an entirely different data type, but that's perfectly okay. Now, any value that's not a primitive will inherit from the object class, but more on that later. Right now we need to talk about this semicolon. Technically, semicolons are optional because if you leave them out, the JavaScript parser will add them automatically. In real life, JavaScript developers will often fight to the death over whether or not to use semicolons. But let is not the only way to define a variable. Another common option is const, which is used for variables that cannot be reassigned later. But the original way to declare a variable is VAR. I would recommend ignoring its existence altogether, although you will find it out in the wild. The reason we have so many different ways to define variables has to do with the lexical environment which determines where variables work and where they don't. There's a global scope, which is where we are right now, which means this variable will be available everywhere. However, if we define a variable inside a function, it then becomes local to that function and cannot be used outside of it. And finally, if you have a statement like an if condition, variables can be scoped inside the braces or block, unless you use VAR for that variable which is not block scope, in which case it will be hoisted up into the local scope for that function. And trust me, you don't want that weirdness in your life. When the function keyword is used by itself, it's called a function definition or statement. Functions are one of the main building blocks in JavaScript and they work by taking an input or argument, then optionally return a value that can be used somewhere else. Now, functions are just objects, which means they can also be used as expressions, allowing them to be used as variables or to construct higher order functions. Where a function is used as an argument or a return value. Functions can also be nested to create a closure that encapsulates data and logic from the rest of the program. Normally, when you call a function that has a variable with a primitive value, it's stored on the call stack, which is the browser's short term memory. However, when you create a closure, the inner function can still access variables in the outer function even after the initial function call. That happens because JavaScript automatically stores the data in the outer function in the heap memory, which will persist between function calls. You'll rarely have to think about that as a developer, but what you're more likely to run into is this it's a keyword that references an object based on how a function is called. When called from the global scope, it references the window object in the browser. However, if that same function is attached to an object and called by that object, this will be a reference to that object and you can manually bind a function to some other object using the bind method. This can be rather confusing, but modern JavaScript has another way to define functions using the arrow syntax. Arrow functions don't have their own this value and they're always anonymous, which makes them ideal for function expressions. Now, one last thing you need to know about functions is that when passing arguments, a primitive like a number is passed by value, which means a copy is created of the original variable. However, if the argument is an object, that means it's stored in the heap and it's passed by reference. That means multiple parts of the code might be mutating the same object. Speaking of which, let's talk about objects. The easiest way to define one is with the object literal syntax using Braces. But there's also an object type that can be created with a constructor using the new keyword. An object contains a collection of key value pairs or properties and values. What's interesting is that objects can inherit properties from each other thanks to a mechanism called the prototype chain. Every object has a private property that links to exactly one prototype. This differs from class based inheritance found in many other languages because we're dealing with real objects that take up memory as opposed to abstract classes in your code. Now, what's confusing is JavaScript supports object oriented programming with a class keyword. However, classes are just syntactic sugar for prototypal inheritance and objects. A class can define a constructor, which is a function that's called when the object is first created. It can also have properties and optionally create, getters and setters to access them. And it more easily encapsulates functions by organizing them as methods on an object instance or making them global to the class name with the static keyword. In addition to objects, JavaScript has a bunch of built in data structures like an array for holding a dynamic collection of indexed items or a set to hold a collection of unique items or map, which also holds a key value pair like an object, but can be more easily looped over along with a variety of other features. Now, what you should also know at this point is that JavaScript is garbage collected. That means it will automatically deallocate objects from memory when they're no longer referenced in your code. However, when you have a map, all the properties will always be referenced. If that's not optimal, there's a weak map and weak set that contain properties that can be garbage collected to reduce memory usage. Now that we have a basic idea of what JavaScript looks like, let's talk about one of its most interesting features, which is its nonblocking event loop. Normally, when you write code in a script, it's executed synchronously line by line, which means the next line can't start until the previous line finishes. With an event loop, we can write asynchronous code in JavaScript that runs in a separate thread pool while the rest of the application continues to execute. This is really important because modern websites often have multiple things going on at the same time, but they only have access to a single thread for computing called the main thread. Without asynchronous code, it would be impossible to multitask. An easy way to demonstrate this is with set timeout, which takes a function as an argument, but won't actually call that function until x number of milliseconds have elapsed. This is called a callback function because it gets in queued in the event loop, only to be called back later when it's ready to execute on the main thread. Callback functions are very common, but when they're overused and become too deeply nested, it leads to a situation called callback hell. Luckily, there are better ways to write async code, like a promise. A promise is a wrapper for a value that's unknown right now but that will resolve to a value in the future, like maybe a call to a third party API that resolves to some data. If something goes wrong, the promise can reject to raise an error. Now, the consumer of the promise can use methods like Then and Catch to handle these two possible outcomes. Or better yet, you can define an async function that will automatically return a promise. Then, in the body of the function, we can pause its execution using the Await keyword to wait for other promises to resolve. And this results in nice readable code. However, in order to implement error handling, you'll want to wrap this code in a try catch block. Now, as your code grows in complexity, it won't all fit in a single file. Luckily, we can use Modules to share code between files. By default, all the code in a file or module is private to that file. However, if there's some code we want to use elsewhere, like a function, we can make it a default export. This allows us to go into a different file and use an import statement to use the function there as well. It's also possible to export multiple values from a single file and then import them by name in the other file. But often what you'll do in JavaScript land is use code written by an entirely different developer. The largest JavaScript package manager is NPM. When you install a package from NPM, it downloads its code into the Node Modules folder in your project. It also provides a package JSON file that will list out all the dependencies used in your project. Now let's go into the code and assume we're building a website on the web. The code will run in the browser, which is based on the Document Object model, where the UI is represented as a tree of HTML elements or nodes. The browser provides APIs to interact with these nodes, with the most important object being the document. The document allows us to grab an individual HTML element using a method called queryselector. It takes a CSS selector as an argument and will find the HTML element that has the same class name, ID, or tag name. It returns an instance of the element class, which itself has a variety of properties and methods to get information about it or change its behavior. In addition, we can grab multiple elements at the same time using Queryselector All. Most importantly, we can listen to events that happen to it, like when a button is clicked with Add Event Listener. We can assign a function that will be called whenever that event takes place. Much of web development revolves around listening to events and updating the UI accordingly. However, one thing that many developers dislike about Vanilla JavaScript is that it results in imperative code where the UI is mutated directly. Many developers now use front end frameworks that produce declarative code where the UI is a function of its input data. These libraries encapsulate JavaScript, HTML and CSS into components, which are then used together to form a component tree to represent the UI. Most importantly, inside a component data is reactive. It can be bound from the JavaScript directly to the HTML. That means anytime data changes, the UI will be updated automatically. Now, after you build a complete JavaScript app, you'll need to take all of your JavaScript files and combine them into a single bundle that can be used by the browser. To handle this process efficiently, you'll need a tool called a module bundler like Vite or Webpack. One problem though, is that sometimes this JavaScript file can get too big, which affects the page load performance, and this can be measured by the network waterfall in your browser DevTools. Luckily, it's possible to split this JavaScript bundle into multiple files, then use dynamic imports in your code to only import that JavaScript when it becomes needed. Now, JavaScript doesn't just run in the browser, but also on the server. Node JS is the most popular runtime, and you can execute JavaScript code at any time using the Node command. This opens the door to frameworks like Electron, which combine Node JS with a browser to create full stack desktop apps with JavaScript or iOS and Android apps with React native. At this point, you've got 99 problems, and JavaScript is every single one of them. If you want to make life easier, use a tool like TypeScript or ESLint that does static analysis to improve your code quality. Congratulations for reaching the end of JavaScript 101. If you want to go beyond this video, I just released a brand new JavaScript course on fireship I O. This video is the introduction to that course, which is followed by a deeper dive into these concepts. Then we work on some hands on projects with a bunch of quizzes along the way. Thanks for watching and I will see you in the next one."
    },
    {
        "url": "https://www.youtube.com/watch?v=r5NQecwZs1A",
        "transcript": "In faraway lands, slaves dig the earth for beautiful gems called quartz, which contain silicon dioxide. Alchemists, or chemical engineers then refine and cook them into silicon substrate, a material that can be doped to act as both a conductor and insulator. Shamans, also known as electrical engineers, then inscribe billions of microscopic symbols on them that can't be seen with a naked eye when lightning passes through them. They can speak the incomprehensible language of binary. Highly trained wizards called software engineers can learn this language to build powerful machines that create illusions. These illusions can then control the way people think and act in the real world. In today's illusion, I will harness this magic to pull back the veil on the almighty computer by looking at four different ways computers actually compute things at the hardware level, because to poot, a computer needs a PU like a CPU, GPU, TPU or DPU. The last 100 years have been crazy. The first truly programmable computer was the Z One, which was created by Conrad Zeus in 1936 in his mom's basement. But then it got blown up in 1943 during the bombardment of Berlin. It's entirely mechanical with over 20,000 parts. It represents binary data with sliding metal sheets. It could do things like boolean algebra and floating point numbers, and had a clock rate of 1 Hz, which means it could execute one instruction per second. To put that in perspective, modern CPUs are measured in gigahertz or billions of cycles per second. Over the next ten years, people thought really hard about how computers should actually work. And in 1945 we got the Von Newman architecture, which is still used in modern chips today. It's the foundational design that describes how data and instructions are stored in the same memory space, then handled by a processing unit. A couple of years later, there is a huge breakthrough with the invention of the transistor, which is a semiconductor that can amplify or switch electrical signals. Like a transistor could represent a one if current passes through it, or a zero if current doesn't pass through it. This was a hugely forward. Then in 1958, the integrated circuit was developed, allowing multiple transistors to be placed on a single silicon chip. Then finally, in 1971, intel released the first commercially available microprocessor that had all the features you know and love from a modern CPU. It was a four bit processor, meaning it could handle four bits of data at a time with approximately 2300 transistors. The clock speed was 740 khz, which was extremely fast at the time. CPUs are pretty complicated, and if you really want to learn how they work, I'd highly recommend reading CPU Land, which does an amazing job of breaking down how they actually execute programs. It's totally free and was written by high schoolers Leximatic and Hack Club. But what I want to focus on is what they're actually used for so we can compare them to the other pus like its name implies, the central processing unit is like the brain of a computer. It runs the operating system, executes programs, and manages hardware. It has access to the system's Ram and includes a hierarchy of caches on the chip itself. For faster data retrieval, a CPU is optimized for sequential computations that require extensive branching and logic. Like, imagine some navigation software that needs to run an algorithm to compute the shortest possible route between two points. The algorithm may have a lot of conditional logic, like, if else, statements that can only be computed one by one or sequentially. A CPU is optimized for this type of work. Now, modern CPUs also have multiple cores, which allows them to do work in parallel, which allows you to use multiple applications on your PC at the same time. And programmers can write code that does multithreading to utilize the cores on your machine to run code in parallel. Check out this video on my second channel if you want to learn how to do that in JavaScript. Now, to make a computer faster, one might think we could just add more and more CPU cores. The reality, though, is that CPU cores are expensive. As the cores scale up, so does power consumption and the heat dissipation requirements. It becomes a matter of diminishing returns, and the extra complexity is just not worth it. At the time of this video, 24 cores is typically the upper limit of higher end chips like Apple's M Two Ultra and Intel's I Nine. But there are massive chips like the 128 core AMD Epic, designed for data centers. Now, when it comes to CPUs, there are multiple different architectures out there. And that's a big deal if you're doing low level systems programming. But every developer should be familiar with Arm and X 86. 64 bit X 86 is what you'll find on most modern desktop computers, while Arm is what you'll find on mobile devices because it has a more simplified instruction set and better power efficiency, which means better battery life. However, this distinction has been changing over the last few years, thanks to the Apple silicon chips, which have proven that the Arm architecture can also work for high performance computing on laptops and desktops. And even Microsoft is investing in running Windows with Arm. In addition, Arm is becoming more and more popular with cloud providers like the Neoverse chip or Amazon's Graviton Three, which allows the cloud to compute more stuff with less power consumption, which is one of the biggest expenses in a data center. But at some point, we've all hit the limitations of a CPU. Like when I try to run pirated Nintendo 64 games on my Raspberry Pi, it lags like crazy. That's because a lot of computation is required to calculate the appearance of all the lights and shadows in a game on demand. Well, that's where the GPU comes in. A graphics processing unit or graphics card is highly optimized for parallel computing. Unlike a CPU with a measly 16 cores, nvidia's RTX 40 80 has nearly 10,000 cores. Each one of these cores can handle a floating point or integer computation per cycle, and that allows games to perform tons of linear algebra in parallel to render graphics instantly every time you push a button on your controller. GPUs are also essential for training deep learning models that perform tons of matrix multiplication on large data sets. This has led to massive demand in the GPU market, and Nvidia's stock price recently landed on the Moon. So he says, okay, give me $200. I gave him $200, and for $200, I bought 15%. I think it was 20% of Nvidia. If GPUs have so many cores, why not just use a GPU over a CPU for everything? The short answer is that not all cores are created equal. A single CPU core is far faster than a single GPU core, and its architecture can handle complex logic and branching. Whereas a GPU is only designed for simple computations, most of the code out in the world can't take advantage of parallel computing and needs to run sequentially with a single thread. A CPU is like a Toyota Camry it's extremely versatile, but can't take you to the Moon. A GPU is more like a rocket ship. It's really fast when you want to go in a straight line, but not really ideal for going to pick up your groceries. As the name implies, GPUs were originally designed for graphics, but nowadays everybody wants them to train an AI that can overthrow the government. But there's actually hardware designed for that use. Case called the TPU, or tensor processing unit. These chips are very similar to GPUs, but designed specifically for tensor operations, like the matrix multiplication required for deep learning. They were developed by Google in 2016 to integrate directly with its TensorFlow software. A TPU contains thousands of these things called multiply accumulators that allows the hardware to perform matrix multiplication without the need to access registers or shared memory like a GPU would. And if you have a neural network that's going to take weeks or months to train, a TPU could save you millions of dollars. That's pretty cool. But that brings us to the newest type of PU the DPU, or data processing unit. The CEO of Nvidia described it as the third major pillar of computing going forward, but you'll likely never use one in your own computer because they're designed specifically for big data centers. They're most like a CPU and typically based on the Arm architecture, but are highly optimized for moving data around. They handle networking functions like packet processing, routing, and security, and also deal with data storage like compression and encryption. The main goal is to relieve the CPU from any data processing jobs, so it can focus on living its best life by doing general purpose computing. And with that, we've looked at four different ways a computer computes but there's one more wild card that we might get to experience in our lifetime, and that's the QPU, or quantum processing unit. All the chips we've looked at so far deal in bits, ones and zeros. But quantum computers deal in qubits, or quantum bits that can exist in a superposition of both states simultaneously. Now, a qubit can represent multiple possibilities at once, but when measured, it collapses into one of the possible states based on probability. These qubits are subject to quantum entanglement, which means the state of one is directly related to another, no matter the distance between them. These properties are used together to create quantum gates, which are like logic gates in regular computers, but work in entirely different ways that I'm too stupid to understand. What I do understand is that if this technology ever gets good, it will completely change the world. Currently, cryptographic systems like RSA are underpinned by the fact that classical algorithms used for factorization would take billions of years to crack with brute force, even with the best computers of today. But quantum computers will be able to run different algorithms, like Schor's algorithm, that's exponentially faster at factorization and thus poses a major threat to modern encryption and security. Luckily, there's no quantum here today that can run this algorithm, and even if there were, they sure as hell wouldn't be telling you and me about it."
    },
    {
        "url": "https://www.youtube.com/watch?v=0_Eif2qGK7I",
        "transcript": "Reverse engineering is the most important part of game hacking. Before you can exploit something, you must discover its vulnerabilities. Game hackers use a suite of tools in conjunction with a deep knowledge of computer science to systematically break down video games. Today, I want to explore some of the fundamental concepts and programs behind reverse engineering. And I hope you stick around, because you might just learn something new before we get into it. Today's video is sponsored by Brilliant. The world of computer science is ever changing and evolving. You must be constantly improving yourself to keep up. And that's precisely why I partnered with Brilliant. Brilliant is an online problem solving platform that offers thousands of lessons on subjects ranging from fundamental mathematics to advanced computer science. The reason I really like Brilliant is because they don't just teach you theory. Brilliant takes a hands on and engaging approach to learning. Their courses are interactive and visually stimulating. With Brilliant, you won't just be memorizing formulas and regurgitating them. Rather, you'll be solving problems and learning. Because this video is about reverse engineering, I'd love to recommend you their course on computer memory. I wish I had it when I was getting started, because this course takes you from basic things like the stack and the heap through virtual memory and even things like optimization and shared libraries. So whether you're a student looking to ace your exams or a professional looking to upskill, you can try everything Brilliant has to offer free for a full 30 days. By visiting brilliant. CAS or by clicking the link in the description down below, the first 200 of you will get 20% off Brilliant's annual premium subscription. Thanks for listening, and let's get back to the video. Reverse engineering is the process of analyzing a product or system to understand how it was designed and how it works. When you download a video game, you don't actually have access to the source code. It's very likely that your video game has been compiled into machine code, which isn't exactly readable to humans. When you run a video game, all the important information such as your health, your ammunition, and so on, are stored in random access memory. We use reverse engineering primarily to find the addresses of these important variables, along with understanding how the program behaves. There are two major types of reverse engineering static and dynamic. Static analysis takes place while your program is not running. It's static because you're simply inspecting the structure and logic of the program. Dynamic analysis takes place while the program is running. We use it to examine the behavior of a program. Reverse engineering techniques are usually used by cybersecurity experts during the exploration of malicious software. Many programmers and game developers also make extensive use of debuggers to test the runtime behavior of their programs. My point is that reverse engineering is used everywhere, and even if you aren't interested in hacking video games, it's still an extremely important skill to acquire for developing high quality software. Let me say that just like with programming, there's no simple way to get good at reverse engineering. All you can do is keep trying repeatedly. Your skill is essentially directly proportional to the amount of experience you have. With that being said, there are a few things that will speed up your progress. Having experience with lower level languages like C or C Plus Plus will be extremely beneficial to you if you're proficient with those languages. It already means that you are familiar with memory in terms of pointers, references and addresses. Next, taking some time to study assembly code will be absolutely invaluable. Almost every dimension of reverse engineering will have you interacting with assembly code. You don't have to become an assembly professional, you just can't be scared of it when you see it. Most people, including myself, have their first taste of reverse engineering through Cheat Engine. Cheat Engine is a free and open source program that is designed for modifying single player games. It has a ton of features, including a memory scanner, multiple debuggers, a disassembler, and much more. Cheat Engine is popular because users can create socalled cheat tables, shareable scripts that run within the Cheat Engine environment. Users with little to no programming experience can reverse engineer and implement cheats without having to write code. And furthermore, as I mentioned, they are shareable. You won't really find experienced cheat developers using Cheat Engine for tables, though. Rather, you'll find them using Cheat Engine exclusively for the memory scanner and debuggers. In terms of static reverse engineering, you're going to want a dedicated disassembler, and the most popular one is IDA Pro. IDA stands for the Interactive Disassembler, and it's a wonderful program, but a license is going to set you back a couple thousand dollars. Luckily, if you can't get yourself a copy of IDA Pro, the National Security Agency has released their free and open source alternative called Gidra. These programs are obviously very different, but their intentions are the same. IDA Pro and Gidra are both primarily disassemblers. They also come with debuggers and best of all, decompilers. Earlier I mentioned that when you download a video game, you don't have access to the source code. A decompiler is a program that generates C pseudocode from the disassembly. It's about as close to source code as you can get. decompilers are not perfect, and sometimes the pseudocode generation is completely off. Hence, you should not rely on them. Rather, focus on learning assembly code, because disassembly will almost never fail you if you can understand it. When you open a program in IDA or Gidra, it will be analyzed and the disassembly will be stored in a database on your disk. When you rename functions and variables, these changes are saved to a database. This way, over a long period of time, you slowly begin to rebuild the program from the inside out. Don't make the mistake of thinking that reverse engineering is a quick process. It even takes long for the people who make it look easy. I've mentioned debuggers a few times already, but I have yet to explain what they are. A debugger is a program that lets you set breakpoints at different steps. During a program's execution, you can think of a breakpoint as a pressure plate or a tripwire. Once the target program reaches a breakpoint, the debugger raises an exception and pauses the program's execution. Once paused, the debugger will show a wealth of information, such as the addresses of local variables, registers, functions, and so on. Debuggers will also show the values of local variables so that you can ensure your program is behaving correctly. If you're looking for a debugger, I would like to recommend X 64 DBG. It's free and open source, plus it has a ton of features. To me, it's like the IDA Pro of dynamic Analysis, except it's free. Like all the previous programs mentioned in this video, it has scripting functionality so that users can extend the program's feature set. Don't let the name fool you, by the way, it works for both 64 bit and 32 bit platforms. All right, it's time for some honorable mentions. Cutter is a free and open source reverse engineering platform that competes with IDA Pro or Gidra. It has a great user interface. It's extremely customizable and extensible, but the project is relatively new. There aren't very many contributors, and in my opinion, it has yet to mature. I'm very sure that as time progresses, Qatar will only get better. Next reclass Net is another free and open source program, but this program has a very specific purpose. It displays a block of memory as multiple data types so that you can determine which one is correct. When you know the data type of a certain offset into the memory block, you set it as so and you can give it a name. Once you are satisfied with your reconstruction of the memory block, reclass will generate a perfectly padded class for you to use in your C or C sharp applications. Alright, ladies and gentlemen, that just about wraps up the video. Thank you for watching. Look forward to more more in depth tutorials on these programs and concepts in the future. As per usual, I'll leave the links to everything mentioned in this video down below, along with a few extra learning resources. If you have any feedback or suggestions, feel free to leave me a comment. I pretty much read all of them. Thank you dearly, to the following patrons for the continued support. I hope you enjoyed the video and I'll catch you guys in the next one. Cheers."
    },
    {
        "url": "https://www.youtube.com/watch?v=2OPVViV-GQk",
        "transcript": "SQL in? No, no. Let's use the SQL injection to hack into a website. Here is our target, Altoro Mutual, an online banking site that is totally real. We're going to use a SQL injection to hack into this website and gain admin privileges. You'll be able to hack this website in like 30 seconds. You now, one of the scariest uses of SQL injection is that bad actors can use a simple login form like this to dump a database of usernames and passwords and then put them on the dark web with a for sale sign and you'll never know about it. Nothing you can do. Well, actually, you could probably try Dashlane, the sponsor of this video. Dashlane will actually monitor the dark web and see if your usernames and passwords are for sale. And if they are, they will alert you. And I have a lot I need to fix that. And then using Dashlane, you can generate a completely random password unique, different from your other passwords, right? You don't use the same password for every website, do you? Anyways, and then Dashlane will store it for you. And this right here is definitely my favorite feature of Dashlane. They'll do passwords and they'll also do multi factor authentication right there in the stinkin'app. I love that. So all your stuff is in one place, keeping you safe and making it a bit more simple to log into sites. I use Dashlane personally for everything and also for my business. And check this out. I get an admin console giving me a dashboard of all my employees'password health scores and it'll tell me whose passwords are compromised. So I can basically force my employees to be secure, which you have to do that, they're not going to listen. So start securing your passwords for free right now. Check it out. Link below. Dashlane.com networkchuck 50. Use the code networkchuck 50 and you'll get 50% off. And did I mention you can secure your passwords everywhere? Phone, tablet, computer. Yeah, it's awesome. So again, here's the website. It's a simple login form and we won't need any fancy tools. All we'll need is a keyboard and some coffee. Never chucked out coffee. Now, our goal with this login form is to use it in a way that will give us access to the underlying database. When you try to log into this website, or really any website, when you hit enter, the website will connect to a database and run a search to see if your username and password exist on the database. If they do, you're in login successful. So here is where a SQL injection comes in. And it's kind of crazy. We know that a lot of websites will do this very thing, query a database and possibly have a query that looks similar to this. And this may look familiar if you watched my previous SQL video. We'll use statements like this to find information in a database. But here we're going to use the beauty of SQL against them. Now in our scenario, we don't know the username and password. So let's take that out and let's first just brute force it. Let's and maybe we'll get lucky. Now as I'm typing this, notice what happens to our query. This will be important for our next step. The username could be admin. It's a popular username for administrative accounts. And we'll try the password. Password, one, two, three. Let's click login. Oh, failed. It was worth a try. But did you keep an eye on our statement? Notice that whatever we typed in was entered here in the query between single quotes. Now here is why that's important in programming and in SQL. When you have a string of characters between quotes, like this can be single or double quotes that's referred to as a string. It's a data type. So looking at our query down here, anything inside quotes is going to be a string. And everything outside of it is a SQL query. And we know that whatever we enter here in the username field and the password field will end up becoming a string inside that query. But what if we could make it not do the this is where the hacking comes in. What if we could send not just a string, but some more SQL query to change what happens to hack what happens? So let's try this. Let's type in our username once more here at admin, but at the very end we're going to add a quote, a single quote, and let's try to log in. Okay, didn't work. We haven't hacked it just yet. But notice something and this will tell you if a website is vulnerable to SQL injection. It's a great way to test that and pay close attention to the error. We have a syntax error because if you look at our query, did you notice what happened? We have another quotation mark right here, a floating quote. And this is fantastic news for us because the reason it got a syntax error is a string is between two quotes. If you only have one quote, then it's not complete. We got a syntax error. It's like freaking out. But now we know that we can insert some extra stuff besides just our string. So now that we know this application is vulnerable to SQL injection, let's try a few SQL injection payloads, which is actually pretty easy. It sounds scary, but it's not too bad. Now before I show you the payload, let's reexamine why our first login failed. I mean it's obvious, right? The username and password were incorrect. But I want you to look at the logic of this query. This SQL statement, what it's saying is both the username admin and the password password, one, two, three have to exist together just like this. If both of those are true, it will evaluate to true and we get a successful login. But in this case, they're not there. It's a different password. So it evaluates to false. So now here's where the magic comes in. Here's where our payload comes in. What if we can make this SQL statement always evaluate to true no matter what we put in? Let's try it out. This first payload is what's known as an or payload. And it's going to look something like this. In our username field right here, I'll do our opening quote. I'll do a space and I'll type in or and I'll do another string. I'll do one as a string one equals and another string one. Now obviously something cool is happening here. But what are we doing? Why are we doing this? Two reasons. First, notice that we added some more SQL code in there. By breaking out of the string with our extra quote, we were able to add some extra SQL query language stuff. Here magic. And here's a fun fact about how SQL will process the operators like and or. That's confusing. When evaluating a statement like this, to see if it's going to be true or false, it will first do the and that's the precedence. And first and then after that or. So now when we try to log in, here's how it will process this logic. And this will all make sense right here. It will first say hey, does username equal admin and password equal password? One, two, three. Does it? Well no. So false. But it's not done yet because we added something extra. And this is the hack. Then it will say this but does the username equal admin or one equal one? Let me ask you a question. Does one equal one? Duh. Yeah right. Will one always equal one? Yes. And that's why we added this nonsensical statement here. This statement will always evaluate to true because no matter what, one equals one. So we added some extra arguments. An extra operator saying hey, does one equal one? Then it's true. And that's the hack here. When it comes to evaluate our or statement, it'll always be true. Let's try it out. Let's click login. Well dang it, it didn't work. But why? It's actually pretty easy. Watch this. Let's take a closer look at it. Do you notice anything weird about our query? Now here's a hint. Count the strings. So we have a string here because we have two quotes. We have a string here, two quotes and we string here two quotes. Well there's an extra quote and that's why we got that syntax error. So let's fix that. It's actually not too bad. Just right here it seems like we have an extra quote at the end. So let's take that one off the end. So now with our syntax looking nice and clean, all complete strings, no errors, let's try to log in. Login. And we did it. We got in. We successfully injected SQL query code by tricking the login prompt. That's pretty nuts. Right? Now, here's a bonus question. Your homework. What if we didn't know the username? What if the username was an admin? Would this still work? Comment below. How would you do it? Now, using payloads like or to subvert the logic of this query, I like it, but it's complicated. There's another way we can do it, and this way is kind of scary powerful. Watch this. Because instead of using or to mess the logic, we're going to add a simple comment. When you're writing code, whether it's Python or SQL, things can get kind of complex. So you often want to make a comment about what you're doing with it. So when people look at your code, they're not like what? You can kind of tell them why you're crazy. So you'll use a special character like the pound sign, or in MySQL's case, which is what we're using right now, you'll have two dashes and a space, and whatever comes after that, no matter what it is, will be ignored. It won't be processed. So what do you say? We use this good thing for a bad thing. We're going to turn a comment into a hack. And watch how simple this is here in our username field, we'll break out of our string once more with an opening quote, and then we'll simply do two dashes and a space. Notice what it did to our query. Let me blow it up real quick. Right after username equals admin, we have a character for comment in SQL telling it to ignore the rest of the code. So where before it said the username, whatever it is and the password whatever it is has to be in the database. Now the statement is simply hey, is the username admin cool? Come on in, no password needed. And that's what's happening. It's ignoring the rest of the statement. And when we try to log in, we're in login successful. So here's your homework. I want you to break into Altoro Mutual. The link is below. Can you break into this website with what you learned in this video? Try it out and let me know in the comments if you actually do it. I would love to hear that you did this. It's kind of fun right now I will say this. This is basic SQL injection. It's often more complicated and a lot easier. And again, while it is an old hacking technique, it's been around for a long time, it still ranks number three in the top list. It's still crazy dangerous and the reason is because companies are lazy or the company has coders that are lazy and they may not even know what to look for as far as SQL injection, because SQL injections can be avoided pretty easily. I'll have some links below, but some things you can do are hey, use prepared statements with parameterized. Can't say that parameterized queries. Use an allow list for input validation. Escape user input before putting it into a query. So what we tried here in this video, that would definitely stop it and use stored procedures. I will not go into detail on all those, and frankly, I don't know how to do any of that. So check the link below and you can learn more. If you're a developer and you're like, oh crap, am I vulnerable? You should probably just double check that real quick just to make sure. If you think you're safe, you're not. Now where do you go from here? Now again, what we did here was basic, but there are a lot more payloads like on here. If you look at payloads, all the things look all the different payloads you could possibly try for a website. And also there are different types of SQL injection. Like now we just did inband error based SQL injection, which is the easiest and most common, but there's Union based, there's blind SQL injection, there's all kinds of things. And I'm hoping that this video gave you a taste for how cool SQL injection is, and you can go off and learn a lot more. Dive deeper, get lost in it. Which union based queries are crazy because you can add additional SQL queries on top of what's already there and possibly dump all the information from a table. Or just drop the table and watch the world burn. Anyways, that's all I got. Catch you guys later."
    }
]